---
title: "Leetcode322解析"
date: 2025-11-03 12:00:00 +0800
categories: [Leetcode]
tags: [Leetcode,DP,recursion,BFS]
---

``` bash
You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.

Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.

You may assume that you have an infinite number of each kind of coin.

 
Example 1:
Input: coins = [1,2,5], amount = 11
Output: 3
Explanation: 11 = 5 + 5 + 1

Example 2:
Input: coins = [2], amount = 3
Output: -1

Example 3:
Input: coins = [1], amount = 0
Output: 0
```

## DP solution

``` bash
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        # dp[n] = min(dp[n-i])+ 1
        if amount == 0:
            return 0

        min_coins = min(coins)
        if min_coins > amount:
            return -1
        elif min_coins == amount:
            return 1

        dp = [-1] * (amount + 1)
        dp[0] = 0

        for i in range(min_coins,amount + 1):
            min_dp = amount + 1
            for j in coins:
                if i < j:
                    continue
                if dp[i - j] >= 0:
                    min_dp = min(min_dp,dp[i - j])
            if min_dp == amount + 1:
                dp[i] = -1
            else:
                dp[i] = min_dp + 1
        return dp[amount]
```

The dynamic programming (DP) solution must be the first method for most people; it's very intuitive. 
However, the above code exceeds 900ms due to many redundant loops. For example, let coins be [10000] and the amount be 20000. We can easily see that the output should be 2, but the code needs to process nearly ten thousand loops to build the DP array (i.e., iterating from dp[10000] to dp[20000], with most of them being -1), which can be optimized."

## Recursion solution

``` bash
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        if amount == 0:
            return 0

        if min(coins) > amount:
            return -1
        
        memo = {}
        def recursion(amount):
            if amount in memo:
                return memo[amount]

            if amount < 0:
                return -1
            if amount == 0:
                return 0
            
            min_sub = amount + 1
            for j in coins:
                temp = recursion(amount - j)
                if temp > -1:
                    min_sub = min(min_sub, temp)

            if min_sub == amount + 1:
                memo[amount] = -1 
                return -1
            
            memo[amount] = min_sub + 1
            return min_sub + 1
        return recursion(amount)
```
It seems we can use recursion to avoid computing redundant iterations.
However, this code exceeds 1100ms.
Normally speaking, recursion is slower than loop form as it has to waste time on allocate stack for function. Each recursive call adds a new frame to the call stack, requiring both memory and time. i.e. time overhead.
PS: when the language or complier support tail recursion optimization, the tail recursion would be automatically complied to loop. Python doesn't support this feature.

### Tail Recursion  
In tail recursion, the recursive call is the last thing the function does, and there are no pending operations after the call.
(for certain language,)It allows compliers to optimize the recursion by reusing the current function's stack frame for the next recursive call, essentially turning the recursion into an iterative process(equivalent to loop).
Here is an example of tail recursion.(PS:Python does not natively support automatic tail call optimization (TCO).)
```bash 
def factorial_tail_recursive(n, accumulator=1):
    if n == 0:
        return accumulator
    else:
        return factorial_tail_recursive(n - 1, n * accumulator)
```

### updated recursion
```bash
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        coins.sort(reverse=True)
        if amount == 0:
            return 0

        if min(coins) > amount:
            return -1
        
        memo = {}
        def recursion(amount):
            if amount in memo:
                return memo[amount]

            if amount < 0:
                return -1
            if amount == 0:
                return 0
            
            min_sub = amount + 1
            for j in coins:
                if min_sub < amount / j: 
                    break
                temp = recursion(amount - j)
                if temp > -1:
                    min_sub = min(min_sub, temp)

            if min_sub == amount + 1:
                memo[amount] = -1 
                return -1
            
            memo[amount] = min_sub + 1
            return min_sub + 1
        return recursion(amount)
```
This version add a judge code (min < amount - j), which can dramatically reduce workload.
How does it work?
As preprocess, the coins array has been sorted, which make sure larger values always come first.
The iterate order is like this: Larger coins -> present coin -> smaller coins
"min_sub < amount / j" menas # of that that contains formar larger coins < # of that doesn't contains formar larger coins.
amount / j is the max value which does not contain any larger coins.
So after this judgement we can skip some calculation if the best combaination must contain larger coins (i.e. it can't only be made up of new coins or smaller coins)
With this optimization, this code can reduce to 140ms.
#TODO:check grammar

## BFS version
```bash
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        if amount == 0:
            return 0

        coins.sort()
        visited = set()

        queue = collections.deque() #curr_amount, count

        queue.append((amount, 0))

        while queue:
            curr, count = queue.popleft()

            if curr == 0:
                return count
            
            if curr < 0:
                continue
            
            if curr in visited:
                continue

            visited.add(curr)
            
            for i in range(0, len(coins)):
                queue.append((curr - coins[i], count + 1))
        return -1
```
BFS solution regards this problem as a shortest path problem. "Shortest path" means smallest amount of coins.
It adds all combination of coins to the queue, and for those with curr = 0, which means coins combination reaches target exactly. And, the first curr reaching 0 is always smallest amount_coins.(not because of pre-sorting but BFS algorithm)
This code is about 736ms.

### updated BFS
```bash
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        if amount == 0:
            return 0

        coins.sort()
        visited = set()

        queue = collections.deque() # start_coin, curr_amount, count

        queue.append((0, amount, 0))

        while queue:
            index, curr, count = queue.popleft()

            if curr == 0:
                return count
            
            if curr < 0:
                continue
            
            if curr in visited:
                continue

            visited.add(curr)
            
            for i in range(index, len(coins)):
                queue.append((i, curr - coins[i], count + 1))
        return -1
```
In fact, it's meangingless to iterating with larger coins after the smaller coin because we have ensured that larger coins always iterated first.
e.g. assume {coins,amonut} is {[5,10,1], 29}, coins_combination(10,10) always appear first and later (5,10,5) or (5,5,10) is meaningless and can be discarded.
If we add a new variable index to record the denimination of coin in each queue update, we can ensure coins iteration order won't be from small to big.
This code is about 240ms.

## Summary
In sec 2 and 3, the code logic is the same
1. In reverse, Subtract coins from the target money until it reaches 0, which can avoid updating impossible combination like in DP solution.
2. Although greedy algorithm can't solve this problem, but it is locally available, when different combination reaches the same temp money, that containing most big coins always is advantageous.